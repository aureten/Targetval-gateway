# app/main.py — consolidated, matching targetval_router.py import os import inspect import asyncio from typing import Any, Dict, List, Optional from fastapi import FastAPI, HTTPException, Header, Query, Depends from fastapi.middleware.cors import CORSMiddleware from pydantic import BaseModel from app.routers import targetval_router from app.routers.targetval_router import Evidence # for isinstance checks # ----------------------------------------------------------------------------- # FastAPI app & CORS # ----------------------------------------------------------------------------- app = FastAPI(title="TARGETVAL Gateway", version="1.2.0") app.add_middleware( CORSMiddleware, allow_origins=os.getenv("CORS_ALLOW_ORIGINS", "*").split(","), allow_credentials=True, allow_methods=["*"], allow_headers=["*"], ) # Mount all 30 module endpoints under their existing routes app.include_router(targetval_router.router) # ----------------------------------------------------------------------------- # Optional gateway-level API key enforcement # ----------------------------------------------------------------------------- GATEWAY_API_KEY = os.getenv("GATEWAY_API_KEY") def _check_gateway_key(header_key: Optional[str], query_key: Optional[str]): """If GATEWAY_API_KEY is set, require it via header or query param.""" if not GATEWAY_API_KEY: return provided = header_key or query_key if provided != GATEWAY_API_KEY: raise HTTPException(status_code=401, detail="Invalid or missing API key") async def require_gateway_key( x_api_key: Optional[str] = Header(default=None, alias="X-API-Key"), api_key: Optional[str] = Query(default=None), ): _check_gateway_key(x_api_key, api_key) # Return the provided key so we can forward it to module functions, if present return x_api_key or api_key # ----------------------------------------------------------------------------- # Modules registry (string → function) for programmatic calls # ----------------------------------------------------------------------------- MODULE_MAP: Dict[str, Any] = { # Bucket 1 – Human Genetics & Causality "genetics_l2g": targetval_router.genetics_l2g, "genetics_rare": targetval_router.genetics_rare, "genetics_mendelian": targetval_router.genetics_mendelian, "genetics_mr": targetval_router.genetics_mr, "genetics_lncrna": targetval_router.genetics_lncrna, "genetics_mirna": targetval_router.genetics_mirna, "genetics_sqtl": targetval_router.genetics_sqtl, "genetics_epigenetics": targetval_router.genetics_epigenetics, # Bucket 2 – Disease Association & Perturbation "assoc_bulk_rna": targetval_router.assoc_bulk_rna, "assoc_bulk_prot": targetval_router.assoc_bulk_prot, "assoc_sc": targetval_router.assoc_sc, "assoc_perturb": targetval_router.assoc_perturb, # Bucket 3 – Expression, Specificity & Localization "expr_baseline": targetval_router.expression_baseline, "expr_localization": targetval_router.expr_localization, "expr_inducibility": targetval_router.expr_inducibility, # Bucket 4 – Mechanistic Wiring & Networks "mech_pathways": targetval_router.mech_pathways, "mech_ppi": targetval_router.mech_ppi, "mech_ligrec": targetval_router.mech_ligrec, # Bucket 5 – Tractability & Modality "tract_drugs": targetval_router.tract_drugs, "tract_ligandability_sm": targetval_router.tract_ligandability_sm, "tract_ligandability_ab": targetval_router.tract_ligandability_ab, "tract_ligandability_oligo": targetval_router.tract_ligandability_oligo, "tract_modality": targetval_router.tract_modality, "tract_immunogenicity": targetval_router.tract_immunogenicity, # Bucket 6 – Clinical Translation & Safety "clin_endpoints": targetval_router.clin_endpoints, "clin_rwe": targetval_router.clin_rwe, "clin_safety": targetval_router.clin_safety, "clin_pipeline": targetval_router.clin_pipeline, # Bucket 7 – Competition & IP "comp_intensity": targetval_router.comp_intensity, "comp_freedom": targetval_router.comp_freedom, } # ----------------------------------------------------------------------------- # Models & helpers for aggregate execution # ----------------------------------------------------------------------------- class AggregateRequest(BaseModel): gene: Optional[str] = None symbol: Optional[str] = None efo: Optional[str] = None condition: Optional[str] = None modules: Optional[List[str]] = None limit: Optional[int] = 50 # catch-all for forward-compat extras (silently ignored by funcs that don't accept them) extra: Optional[Dict[str, Any]] = None def _bind_kwargs(func: Any, provided: Dict[str, Any]) -> Dict[str, Any]: """Return only the kwargs that the target function actually accepts.""" sig = inspect.signature(func) allowed = set(sig.parameters.keys()) return {k: v for k, v in provided.items() if k in allowed} async def _run_module( name: str, func: Any, provided_key: Optional[str], gene: Optional[str], symbol: Optional[str], efo: Optional[str], condition: Optional[str], limit: Optional[int], extra: Optional[Dict[str, Any]], ): """Invoke a single module function safely and return (name, result_dict).""" # Default symbol to gene if only one is provided symbol_effective = symbol or gene kwargs_all: Dict[str, Any] = { "gene": gene, "symbol": symbol_effective, "efo": efo, "condition": condition, "disease": condition, # some functions use 'disease' as the param name "limit": limit, "x_api_key": provided_key, } if extra: # allow extras, but bind will filter kwargs_all.update(extra) kwargs = _bind_kwargs(func, kwargs_all) try: result = func(**kwargs) if asyncio.iscoroutine(result): result = await result # Coerce Evidence Pydantic model to plain dict if isinstance(result, Evidence): return name, result.dict() if isinstance(result, dict): return name, result # Unexpected type; wrap return name, { "status": "ERROR", "source": "Unexpected return type", "fetched_n": 0, "data": {}, "citations": [], "fetched_at": 0.0, } except HTTPException as he: return name, { "status": "ERROR", "source": f"HTTP {he.status_code}: {he.detail}", "fetched_n": 0, "data": {}, "citations": [], "fetched_at": 0.0, } except Exception as e: return name, { "status": "ERROR", "source": str(e), "fetched_n": 0, "data": {}, "citations": [], "fetched_at": 0.0, } # ----------------------------------------------------------------------------- # Convenience service endpoints # ----------------------------------------------------------------------------- @app.get("/healthz") async def healthz(): return {"ok": True, "modules": len(MODULE_MAP)} @app.get("/modules") async def list_modules(): return sorted(MODULE_MAP.keys()) @app.get("/module/{name}") async def run_single_module( name: str, gene: Optional[str] = Query(default=None), symbol: Optional[str] = Query(default=None), efo: Optional[str] = Query(default=None), condition: Optional[str] = Query(default=None), limit: int = Query(default=50, ge=1, le=1000), provided_key: Optional[str] = Depends(require_gateway_key), ): func = MODULE_MAP.get(name) if not func: raise HTTPException(status_code=404, detail=f"Unknown module: {name}") _, res = await _run_module( name=name, func=func, provided_key=provided_key, gene=gene, symbol=symbol, efo=efo, condition=condition, limit=limit, extra=None, ) return res @app.post("/aggregate") async def aggregate( body: AggregateRequest, provided_key: Optional[str] = Depends(require_gateway_key), ): # Determine which modules to run modules = body.modules or list(MODULE_MAP.keys()) # Validate module names early unknown = [m for m in modules if m not in MODULE_MAP] if unknown: raise HTTPException(status_code=400, detail=f"Unknown modules: {', '.join(unknown)}") # Fan-out with backpressure handled in router helpers tasks = [ _run_module( name=m, func=MODULE_MAP[m], provided_key=provided_key, gene=body.gene, symbol=body.symbol, efo=body.efo, condition=body.condition, limit=body.limit or 50, extra=body.extra, ) for m in modules ] results = await asyncio.gather(*tasks) return { "query": { "gene": body.gene, "symbol": body.symbol or body.gene, "efo": body.efo, "condition": body.condition, "limit": body.limit or 50, "modules": modules, }, "results": {name: res for name, res in results}, }
